function itrf = sp32itrf(sp3, order, interval, period)
%sp32itrf: transform sp3 data to ITRF coordinates 
%
% Syntax: itrf = sp32itrf(sp3, interval, period)
%
% INPUT:
%   sp3         - matrix of the sp3  precise ephemeris parameters 
%                 (generated by /input/read_sp3.m)
%   OPTIONAL:
%   order       - order of lagrange polynominal [Optional, default 5] 
%   interval    - sampling interval (sec) [Optinal, default 300s]
%   period      - sampling period from the first epoch of each satellite (sec)
%                 [Optional, default 86400s]
%
% OUTPUT:
%   itrf        - (x,y,z) coordinates in earth-fixed itrf
%
%   itrf(1)     = sat number
%   itrf(2:7)   = toc (Time of Clock) [year,month,day,hour,minute,second]
%   itrf(8:10)   = coordinates in earth-fixed WGS84 [x, y, z] 
%
% EXAMPLE:
%   itrf = sp32itrf(sp3)
%   itrf = sp32itrf(sp3, 300)
%   itrf = sp32itrf(sp3, 300, 86400)
%
% See also READ_SP3
%
% check input arguments

if nargin < 2
   order = 5;
end
if nargin < 3
    interval = 300;
end
if nargin < 4
   period = 86400;
end
if nargin > 4
   disp("ERROR: The numbers of input arguments exceed 4. Unexpected exit.");
   return
end

% get satellite list
sat_list = unique(sp3(:,1));
% attach GPST to sp3
gpst = cal2gpst(sp3(:,2:7));
sp3 = [sp3, gpst]; % attach to col 16 & 17

% allocate
itrf = nan(int64(period/interval)+1, 10); %sat, cal[year,month,day,hour,minute,second], x, y, z
idx = 0; % index of itrf

% start sampling for each satellite
for i = 1:length(sat_list)
    sat = sat_list(i); % sat number
    sp3_ref = sp3(sp3(:,1)==sat,:); % reference navigation message of sat
    num_ref = length(sp3_ref(:,1)); % length of list of sp3_ref
    start_t = sp3_ref(1,17);
    end_t = period + start_t;
    M = 10 ^ floor(log10(start_t)); % digits of time (just a large number)
%     M = (start_t + end_t)/2;
    if end_t > sp3_ref(end,17)
        warning("Period may be too long, possibly resulting in imprecise coordinates for sat %s at %s.",sat2prn(sat),string(end_t));
    end
    % get coefficients of order-th lagrange polynominal
    coef = nan([3, order, num_ref-order+1]); % coefficients
    for low = 1:(num_ref-order+1)
        high = low+order-1;
        x_ref = sp3_ref(low:high, 17) / M; % time / (10^digits)
        y_ref = sp3_ref(low:high, 8:10); % xyz
        coef(:,:,low) = lagrange_coef(x_ref, y_ref); % 3 x order
    end
    for t = start_t:interval:end_t
        % select the best polynominal
        ref_poly = floor(sum(sp3_ref(:,17) <= t) - order/2);
        if ref_poly <= 0
            ref_poly = 1;   % left limit
        end
        if ref_poly + order - 1 > num_ref
            ref_poly = num_ref - order + 1; % right limit
        end
        % calculate xyz
        t_e = t / M;
        x_e = polyval(coef(1,:,ref_poly),t_e); % !!! too large
        y_e = polyval(coef(2,:,ref_poly),t_e);
        z_e = polyval(coef(3,:,ref_poly),t_e);
        idx = idx + 1;
        itrf(idx, :) = [sat, gpst2cal([sp3_ref(1,16), t]), x_e, y_e, z_e];
    end
end
% remove the extra preallocated memory
itrf(idx+1:end,:) = [];

end

function coef = lagrange_coef(x,y)
% lagrange_coef: get lagrange polynominal interpolation coefficients by x,y
% INPUT
%   x       - nx1
%   y       - nxm
%
% OUTPUT
%   coef    - coefficients matrix of lagrange polynominal [m x n]
% 
coef = 0;
for i = 1:length(x)
    p = 1;
    for j = 1:length(x)
        if j ~= i
            c = poly(x(j)) / (x(i) - x(j));
            p = conv(p,c); % 1 x n
        end
    end
    term = y(i,:)' * p; % mx1 x 1xn
    coef = coef + term; % m x n
end

end
